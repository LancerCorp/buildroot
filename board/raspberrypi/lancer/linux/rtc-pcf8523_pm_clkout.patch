--- /drivers/rtc/rtc-pcf8523.c	2019-07-30 08:37:58.000000000 -0500
+++ /drivers/rtc/rtc-pcf8523.c	2019-08-06 16:00:25.011630195 -0500
@@ -35,6 +35,21 @@
 #define REG_MONTHS   0x08
 #define REG_YEARS    0x09
 
+#define REG_OFFSET   0x0e
+#define REG_OFFSET_MODE BIT(7)
+
+#define REG_TMR_CLOCKOUT_CRTL   0x0f
+#define REG_TMR_CLOCKOUT_CRTL_COF_MASK   0x1C
+#define REG_TMR_CLOCKOUT_CRTL_COF_32768 (0 << 5) | (0 << 4) | (0 << 3) 
+#define REG_TMR_CLOCKOUT_CRTL_COF_16384 (0 << 5) | (0 << 4) | (1 << 3)  
+#define REG_TMR_CLOCKOUT_CRTL_COF_8192  (0 << 5) | (1 << 4) | (0 << 3)
+#define REG_TMR_CLOCKOUT_CRTL_COF_4096  (0 << 5) | (1 << 4) | (1 << 3)
+#define REG_TMR_CLOCKOUT_CRTL_COF_1024  (1 << 5) | (0 << 4) | (0 << 3)
+#define REG_TMR_CLOCKOUT_CRTL_COF_32    (1 << 5) | (0 << 4) | (1 << 3)
+#define REG_TMR_CLOCKOUT_CRTL_COF_1     (1 << 5) | (1 << 4) | (0 << 3)
+#define REG_TMR_CLOCKOUT_CRTL_COF_HIZ   (1 << 5) | (1 << 4) | (1 << 3)
+
+
 struct pcf8523 {
 	struct rtc_device *rtc;
 };
@@ -82,6 +97,18 @@
 	return 0;
 }
 
+static int pcf8523_voltage_low(struct i2c_client *client)
+{
+	u8 value;
+	int err;
+
+	err = pcf8523_read(client, REG_CONTROL3, &value);
+	if (err < 0)
+		return err;
+
+	return !!(value & REG_CONTROL3_BLF);
+}
+
 static int pcf8523_select_capacitance(struct i2c_client *client, bool high)
 {
 	u8 value;
@@ -121,6 +148,24 @@
 	return 0;
 }
 
+static int pcf8523_set_clkout(struct i2c_client *client, u8 clkout)
+{
+	u8 value;
+	int err;
+
+	err = pcf8523_read(client, REG_TMR_CLOCKOUT_CRTL, &value);
+	if (err < 0)
+		return err;
+
+	value = (value & ~REG_TMR_CLOCKOUT_CRTL_COF_MASK) | clkout;
+
+	err = pcf8523_write(client, REG_TMR_CLOCKOUT_CRTL, value);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
 static int pcf8523_stop_rtc(struct i2c_client *client)
 {
 	u8 value;
@@ -164,6 +209,14 @@
 	struct i2c_msg msgs[2];
 	int err;
 
+	err = pcf8523_voltage_low(client);
+	if (err < 0) {
+		return err;
+	} else if (err > 0) {
+		dev_err(dev, "low voltage detected, time is unreliable\n");
+		return -EINVAL;
+	}
+
 	msgs[0].addr = client->addr;
 	msgs[0].flags = 0;
 	msgs[0].len = 1;
@@ -209,7 +262,7 @@
 	tm->tm_mon = bcd2bin(regs[5] & 0x1f) - 1;
 	tm->tm_year = bcd2bin(regs[6]) + 100;
 
-	return rtc_valid_tm(tm);
+	return 0;
 }
 
 static int pcf8523_rtc_set_time(struct device *dev, struct rtc_time *tm)
@@ -267,17 +320,13 @@
 			     unsigned long arg)
 {
 	struct i2c_client *client = to_i2c_client(dev);
-	u8 value;
-	int ret = 0, err;
+	int ret;
 
 	switch (cmd) {
 	case RTC_VL_READ:
-		err = pcf8523_read(client, REG_CONTROL3, &value);
-		if (err < 0)
-			return err;
-
-		if (value & REG_CONTROL3_BLF)
-			ret = 1;
+		ret = pcf8523_voltage_low(client);
+		if (ret < 0)
+			return ret;
 
 		if (copy_to_user((void __user *)arg, &ret, sizeof(int)))
 			return -EFAULT;
@@ -291,10 +340,47 @@
 #define pcf8523_rtc_ioctl NULL
 #endif
 
+static int pcf8523_rtc_read_offset(struct device *dev, long *offset)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int err;
+	u8 value;
+	s8 val;
+
+	err = pcf8523_read(client, REG_OFFSET, &value);
+	if (err < 0)
+		return err;
+
+	/* sign extend the 7-bit offset value */
+	val = value << 1;
+	*offset = (value & REG_OFFSET_MODE ? 4069 : 4340) * (val >> 1);
+
+	return 0;
+}
+
+static int pcf8523_rtc_set_offset(struct device *dev, long offset)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	long reg_m0, reg_m1;
+	u8 value;
+
+	reg_m0 = clamp(DIV_ROUND_CLOSEST(offset, 4340), -64L, 63L);
+	reg_m1 = clamp(DIV_ROUND_CLOSEST(offset, 4069), -64L, 63L);
+
+	if (abs(reg_m0 * 4340 - offset) < abs(reg_m1 * 4069 - offset))
+		value = reg_m0 & 0x7f;
+	else
+		value = (reg_m1 & 0x7f) | REG_OFFSET_MODE;
+
+	return pcf8523_write(client, REG_OFFSET, value);
+}
+
 static const struct rtc_class_ops pcf8523_rtc_ops = {
 	.read_time = pcf8523_rtc_read_time,
 	.set_time = pcf8523_rtc_set_time,
 	.ioctl = pcf8523_rtc_ioctl,
+	.read_offset = pcf8523_rtc_read_offset,
+	.set_offset = pcf8523_rtc_set_offset,
 };
 
 static int pcf8523_probe(struct i2c_client *client,
@@ -314,7 +400,11 @@
 	if (err < 0)
 		return err;
 
-	err = pcf8523_set_pm(client, 0);
+	err = pcf8523_set_pm(client, REG_CONTROL3_PM_DSM | REG_CONTROL3_PM_BLD);
+	if (err < 0)
+		return err;
+	
+	err =  pcf8523_set_clkout(client, REG_TMR_CLOCKOUT_CRTL_COF_HIZ);
 	if (err < 0)
 		return err;
 
